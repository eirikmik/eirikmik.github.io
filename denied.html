<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Status Report: DENIED</title>
<meta property="og:title" content="Status Report: DENIED">
<meta property="og:description" content="A tribute to Optimus Prisme, ruler of the weekly status report.">
<meta property="og:type" content="website">
<meta property="og:image" content="https://eirikmik.github.io/og-image.png">
<meta property="og:image:width" content="1283">
<meta property="og:image:height" content="960">
<meta name="twitter:image" content="https://eirikmik.github.io/og-image.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Status Report: DENIED">
<meta name="twitter:description" content="A tribute to Optimus Prisme, ruler of the weekly status report.">
<style>
* { margin: 0; padding: 0; }
body { background: #000; overflow: hidden; }
canvas { display: block; }
#hud {
  position: absolute; bottom: 0; left: 0; right: 0;
  height: 60px; background: rgba(30,30,30,0.85); border-top: 3px solid #888;
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 30px; font-family: monospace; color: #fff; font-size: 18px;
  z-index: 10;
}
#hud .health { color: #f44; font-size: 24px; font-weight: bold; }
#hud .ammo { color: #ff0; font-size: 24px; font-weight: bold; }
#hud .kills { color: #0f0; font-size: 24px; font-weight: bold; }
#msg {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  font-family: monospace; color: #f00; font-size: 48px; font-weight: bold;
  text-shadow: 0 0 20px #f00; display: none; text-align: center; z-index: 20;
}
#crosshair {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  color: #0f0; font-size: 24px; pointer-events: none; opacity: 0.7; z-index: 10;
}
#start {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  font-family: monospace; color: #f00; font-size: 36px; font-weight: bold;
  text-shadow: 0 0 20px #f00; text-align: center; cursor: pointer; z-index: 20;
}
#start span { font-size: 18px; color: #aaa; display: block; margin-top: 20px; }
#version { position: absolute; bottom: 70px; right: 10px; font-family: monospace; font-size: 11px; color: #444; z-index: 20; }
#minimap {
  position: absolute; top: 10px; right: 10px;
  border: 2px solid #888; z-index: 10;
}
#damageFlash {
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(255,0,0,0); pointer-events: none; z-index: 5;
}
</style>
</head>
<body>
<div id="damageFlash"></div>
<canvas id="minimap" width="160" height="160"></canvas>
<div id="hud">
  <div class="health">HEALTH: <span id="hp">100</span>%</div>
  <div class="ammo">AMMO: <span id="ammo">50</span></div>
  <div class="kills">KILLS: <span id="kills">0/15</span></div>
</div>
<div id="crosshair">+</div>
<div id="msg"></div>
<div id="start">STATUS REPORT: DENIED<span>Click to start<br>WASD = Move | Mouse = Look | Click = Shoot | Space = Jump</span></div>
<div id="version">v1.2.0</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.min.js"></script>
<script>
// ============================================================
// LEVEL DATA
// ============================================================
const LEVELS = [
  {
    name: 'The Compound',
    map: [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,2,2,2,0,0,0,0,0,0,3,3,3,0,0,0,0,1],
      [1,0,0,2,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,1],
      [1,0,0,2,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,4,4,0,0,4,4,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,4,0,0,0,0,4,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,4,0,0,0,0,4,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,4,4,0,0,4,4,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,1],
      [1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,1],
      [1,0,0,3,3,3,0,0,0,0,0,0,0,2,2,2,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
    playerStart: { x: 2, y: 2 },
    playerAmmo: 50,
    enemySpots: [
      [5,10],[14,5],[10,14],[17,17],[9,9],
      [3,16],[16,3],[14,14],[5,5],[10,2],
      [17,10],[2,10],[9,17],[15,9],[6,15],
    ],
    pointLights: [
      [9.5, 2, 9.5],
      [3, 2, 3],
      [16, 2, 16],
      [3, 2, 16],
      [16, 2, 3],
    ],
    prismPos: { x: 9.5, z: 9.5 },
    healthKits: [[17,1],[1,17],[8,13]],
  },
  {
    name: 'The Corridors',
    map: [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
      [1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
      [1,0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0,0,1],
      [1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,3,0,0,4,4,0,0,0,4,4,0,0,3,0,0,0,1],
      [1,0,0,3,0,0,4,0,0,0,0,0,4,0,0,3,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,0,0,0,0,0,0,2,2,0,0,0,0,0,0,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,3,0,0,4,0,0,0,0,0,4,0,0,3,0,0,0,1],
      [1,0,0,3,0,0,4,4,0,0,0,4,4,0,0,3,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,1,1],
      [1,0,0,0,2,0,0,3,3,3,3,3,0,0,2,0,0,0,0,1],
      [1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
    playerStart: { x: 2, y: 2 },
    playerAmmo: 40,
    enemySpots: [
      [5,1],[14,1],[9,5],[5,8],[14,8],
      [2,5],[17,5],[9,9],[2,11],[17,11],
      [5,12],[14,12],[9,15],[2,17],[17,17],
      [7,3],[12,3],[9,11],
    ],
    pointLights: [
      [9.5, 2, 9.5],
      [2, 2, 2],
      [17, 2, 17],
      [2, 2, 17],
      [17, 2, 2],
      [9.5, 2, 3],
      [9.5, 2, 16],
    ],
    prismPos: { x: 9.5, z: 9.5 },
    healthKits: [[1,1],[17,18],[9,11]],
  },
  {
    name: 'The Arena',
    map: [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,1],
      [1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,4,0,0,0,0,0,4,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1],
      [1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
    playerStart: { x: 2, y: 2 },
    playerAmmo: 60,
    enemySpots: [
      [5,2],[18,2],[11,5],[5,7],[18,7],
      [2,11],[21,11],[11,11],[2,15],[21,15],
      [5,17],[18,17],[11,19],[8,9],[14,9],
      [8,14],[14,14],[11,2],[11,21],[3,5],
      [20,5],[3,18],
    ],
    pointLights: [
      [11.5, 2, 11.5],
      [3, 2, 3],
      [20, 2, 20],
      [3, 2, 20],
      [20, 2, 3],
      [11.5, 2, 3],
      [11.5, 2, 20],
      [3, 2, 11.5],
      [20, 2, 11.5],
    ],
    prismPos: { x: 11.5, z: 11.5 },
    healthKits: [[1,1],[22,22],[11,3],[11,20]],
  },
];

let currentLevel = 0;
let MAP = LEVELS[0].map;
let MAP_W = MAP[0].length;
let MAP_H = MAP.length;
const CELL = 4; // world units per cell
const WALL_H = 4;

// ============================================================
// WALL COLORS / TEXTURES
// ============================================================
const WALL_COLORS = {
  1: { r: 128, g: 128, b: 128 },
  2: { r: 160, g: 60, b: 60 },
  3: { r: 60, g: 100, b: 160 },
  4: { r: 60, g: 140, b: 60 },
};
// ============================================================
// LOGO BANNERS (Crayon & SoftwareONE)
// ============================================================
const CRAYON_LOGO_B64 = 'data:image/png;base64,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';
const SWONE_LOGO_B64 = 'data:image/png;base64,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';

function createBannerTexture(logoB64) {
  const canvas = document.createElement('canvas');
  canvas.width = 512; canvas.height = 256;
  const ctx = canvas.getContext('2d');
  // Dark banner background
  ctx.fillStyle = '#111122';
  ctx.fillRect(0, 0, 512, 256);
  // Subtle gold border
  ctx.strokeStyle = '#8b7355';
  ctx.lineWidth = 6;
  ctx.strokeRect(6, 6, 500, 244);
  const tex = new THREE.CanvasTexture(canvas);
  const img = new Image();
  img.onload = function() {
    const scale = Math.min(440 / img.width, 200 / img.height);
    const w = img.width * scale;
    const h = img.height * scale;
    ctx.drawImage(img, (512 - w) / 2, (256 - h) / 2, w, h);
    tex.needsUpdate = true;
  };
  img.src = logoB64;
  return tex;
}

function addLogoBanners() {
  const lvl = LEVELS[currentLevel];
  const pcx = lvl.prismPos.x;
  const pcz = lvl.prismPos.z;
  const checkRows = [];
  for (let r = Math.floor(pcz) - 2; r <= Math.ceil(pcz) + 2; r++) {
    if (r >= 0 && r < MAP_H) checkRows.push(r);
  }
  // Find nearest wall east and west of prism
  let eastCol = MAP_W, eastRow = Math.floor(pcz);
  let westCol = -1, westRow = Math.floor(pcz);
  for (const row of checkRows) {
    for (let c = Math.ceil(pcx) + 1; c < MAP_W; c++) {
      if (MAP[row][c] !== 0) { if (c < eastCol) { eastCol = c; eastRow = row; } break; }
    }
    for (let c = Math.floor(pcx) - 1; c >= 0; c--) {
      if (MAP[row][c] !== 0) { if (c > westCol) { westCol = c; westRow = row; } break; }
    }
  }
  if (eastCol >= MAP_W || westCol < 0) return;

  const bannerW = 3.2, bannerH = 1.6;
  const bannerGeo = new THREE.PlaneGeometry(bannerW, bannerH);

  // Crayon banner on east wall inner face (facing west toward prism)
  const crayonTex = createBannerTexture(CRAYON_LOGO_B64);
  const crayonMat = new THREE.MeshStandardMaterial({
    map: crayonTex, roughness: 0.4, metalness: 0.05,
    emissive: new THREE.Color(0x222233), emissiveIntensity: 0.3,
  });
  const crayonBanner = new THREE.Mesh(bannerGeo, crayonMat);
  crayonBanner.position.set(
    eastCol * CELL + 0.05,
    WALL_H * 0.55,
    pcz * CELL
  );
  crayonBanner.rotation.y = -Math.PI / 2;
  scene.add(crayonBanner);
  levelObjects.push(crayonBanner);

  // SoftwareONE banner on west wall inner face (facing east toward prism)
  const swoneTex = createBannerTexture(SWONE_LOGO_B64);
  const swoneMat = new THREE.MeshStandardMaterial({
    map: swoneTex, roughness: 0.4, metalness: 0.05,
    emissive: new THREE.Color(0x222233), emissiveIntensity: 0.3,
  });
  const swoneBanner = new THREE.Mesh(bannerGeo.clone(), swoneMat);
  swoneBanner.position.set(
    (westCol + 1) * CELL - 0.05,
    WALL_H * 0.55,
    pcz * CELL
  );
  swoneBanner.rotation.y = Math.PI / 2;
  scene.add(swoneBanner);
  levelObjects.push(swoneBanner);
}


const TEX_SIZE = 64;
function generateBrickTexture(baseR, baseG, baseB) {
  const c = document.createElement('canvas');
  c.width = TEX_SIZE; c.height = TEX_SIZE;
  const tc = c.getContext('2d');
  const id = tc.createImageData(TEX_SIZE, TEX_SIZE);
  const d = id.data;
  const brickH = 8, brickW = 16, mortarW = 1;
  for (let y = 0; y < TEX_SIZE; y++) {
    const row = Math.floor(y / brickH);
    const yInBrick = y % brickH;
    const offset = (row % 2) * (brickW / 2);
    for (let x = 0; x < TEX_SIZE; x++) {
      const xShifted = (x + offset) % TEX_SIZE;
      const xInBrick = xShifted % brickW;
      const idx = (y * TEX_SIZE + x) * 4;
      const isMortarY = yInBrick < mortarW;
      const isMortarX = xInBrick < mortarW;
      if (isMortarY || isMortarX) {
        const mv = 40 + ((x * 7 + y * 13) % 15);
        d[idx] = mv; d[idx+1] = mv; d[idx+2] = mv; d[idx+3] = 255;
      } else {
        const brickCol = Math.floor(xShifted / brickW);
        const seed = row * 17 + brickCol * 31;
        const variation = ((seed * seed * 214013 + 2531011) >> 8) % 40 - 20;
        const noise = ((x * 2654435761 + y * 340573321) >> 16) % 20 - 10;
        const edgeDist = Math.min(xInBrick - mortarW, brickW - 1 - xInBrick, yInBrick - mortarW, brickH - 1 - yInBrick);
        const edgeShade = edgeDist <= 1 ? 0.8 : 1.0;
        const highlight = yInBrick === mortarW ? 1.15 : 1.0;
        let r = Math.floor((baseR + variation + noise) * edgeShade * highlight);
        let g = Math.floor((baseG + variation * 0.6 + noise * 0.7) * edgeShade * highlight);
        let b = Math.floor((baseB + variation * 0.4 + noise * 0.5) * edgeShade * highlight);
        d[idx] = Math.max(0, Math.min(255, r));
        d[idx+1] = Math.max(0, Math.min(255, g));
        d[idx+2] = Math.max(0, Math.min(255, b));
        d[idx+3] = 255;
      }
    }
  }
  tc.putImageData(id, 0, 0);
  return c;
}

// ============================================================
// THREE.JS SETUP
// ============================================================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111118);
scene.fog = new THREE.FogExp2(0x111118, 0.025);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth / (window.innerHeight - 63), 0.1, 200);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight - 63);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFShadowMap;
document.body.insertBefore(renderer.domElement, document.body.firstChild);

// ============================================================
// PRISMATIC ENV MAP (rainbow cubemap for reflections)
// ============================================================
function createPrismaticEnvMap() {
  const size = 128;
  const faces = [];
  const palettes = [
    [[20,15,105],[72,22,116],[128,44,84]], // +x
    [[35,18,118],[92,28,102],[24,52,112]], // -x
    [[18,72,118],[16,88,108],[40,38,122]], // +y
    [[52,16,128],[82,14,128],[58,30,110]], // -y
    [[44,20,138],[30,30,92],[26,62,104]], // +z
    [[112,35,92],[20,15,105],[35,18,118]], // -z
  ];
  for (let f = 0; f < 6; f++) {
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const ctx = c.getContext('2d');
    const pal = palettes[f];
    const grad = ctx.createLinearGradient(0, 0, size, size);
    grad.addColorStop(0, `rgb(${pal[0].join(',')})`);
    grad.addColorStop(0.5, `rgb(${pal[1].join(',')})`);
    grad.addColorStop(1, `rgb(${pal[2].join(',')})`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, size, size);
    // Add some sparkle noise
    const id = ctx.getImageData(0, 0, size, size);
    const d = id.data;
    for (let i = 0; i < d.length; i += 4) {
      const n = Math.random() * 30 - 15;
      d[i] = Math.max(0, Math.min(255, d[i] + n));
      d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
      d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
    }
    ctx.putImageData(id, 0, 0);
    faces.push(c);
  }
  const cubeTexture = new THREE.CubeTexture(faces);
  cubeTexture.needsUpdate = true;
  return cubeTexture;
}
const envMap = createPrismaticEnvMap();

// ============================================================
// LIGHTING
// ============================================================
const ambientLight = new THREE.AmbientLight(0x222233, 0.4);
scene.add(ambientLight);

const hemiLight = new THREE.HemisphereLight(0x3344aa, 0x221111, 0.5);
scene.add(hemiLight);

// Level-specific objects tracked for cleanup
let levelObjects = [];

// Player flashlight
const flashlight = new THREE.SpotLight(0xffeedd, 15, 40, Math.PI/5, 0.4, 1.5);
flashlight.castShadow = true;
flashlight.shadow.mapSize.width = 512;
flashlight.shadow.mapSize.height = 512;
flashlight.shadow.camera.near = 0.5;
flashlight.shadow.camera.far = 40;
camera.add(flashlight);
flashlight.position.set(0, 0, 0);
flashlight.target.position.set(0, 0, -1);
camera.add(flashlight.target);
scene.add(camera);

// ============================================================
// LEVEL GEOMETRY
// ============================================================
function clearLevel() {
  for (const obj of levelObjects) {
    scene.remove(obj);
    if (obj.geometry) obj.geometry.dispose();
    if (obj.material) {
      if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
      else obj.material.dispose();
    }
  }
  levelObjects = [];
  // Remove enemy models (dispose cloned materials) and shards
  for (const e of enemies) {
    if (e.model) {
      e.model.traverse(child => {
        if (child.isMesh) {
          if (child.material) child.material.dispose();
        }
      });
      scene.remove(e.model);
    }
  }
  for (const s of shardPool) {
    s.material.dispose();
    scene.remove(s);
  }
  shardPool.length = 0;
  enemies = [];
  for (const kit of healthKits) {
    if (kit.model) scene.remove(kit.model);
  }
  healthKits = [];
  if (window._prism) {
    window._prism = null;
  }
}

function loadLevelData(levelIndex) {
  const lvl = LEVELS[levelIndex];
  MAP = lvl.map;
  MAP_W = MAP[0].length;
  MAP_H = MAP.length;
}

function buildLevel() {
  const lvl = LEVELS[currentLevel];

  // Create wall textures as Three.js textures
  const wallMaterials = {};
  for (const [wallType, col] of Object.entries(WALL_COLORS)) {
    const texCanvas = generateBrickTexture(col.r, col.g, col.b);
    const tex = new THREE.CanvasTexture(texCanvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.magFilter = THREE.NearestFilter;
    wallMaterials[wallType] = new THREE.MeshStandardMaterial({
      map: tex,
      roughness: 0.85,
      metalness: 0.05,
    });
  }

  // Build walls as instanced meshes (one draw call per wall type)
  const wallGeo = new THREE.BoxGeometry(CELL, WALL_H, CELL);
  // Count instances per wall type
  const wallCounts = {};
  for (let row = 0; row < MAP_H; row++) {
    for (let col = 0; col < MAP_W; col++) {
      const wt = MAP[row][col];
      if (wt !== 0) wallCounts[wt] = (wallCounts[wt] || 0) + 1;
    }
  }
  // Create one InstancedMesh per wall type
  const dummy = new THREE.Object3D();
  for (const [wallType, count] of Object.entries(wallCounts)) {
    const instMesh = new THREE.InstancedMesh(wallGeo, wallMaterials[wallType], count);
    instMesh.receiveShadow = true;
    let idx = 0;
    for (let row = 0; row < MAP_H; row++) {
      for (let col = 0; col < MAP_W; col++) {
        if (MAP[row][col] !== parseInt(wallType)) continue;
        dummy.position.set(col * CELL + CELL / 2, WALL_H / 2, row * CELL + CELL / 2);
        dummy.updateMatrix();
        instMesh.setMatrixAt(idx++, dummy.matrix);
      }
    }
    scene.add(instMesh);
    levelObjects.push(instMesh);
  }

  // Floor
  const floorGeo = new THREE.PlaneGeometry(MAP_W * CELL, MAP_H * CELL);
  const floorTex = generateBrickTexture(50, 50, 55);
  const floorTexture = new THREE.CanvasTexture(floorTex);
  floorTexture.wrapS = THREE.RepeatWrapping;
  floorTexture.wrapT = THREE.RepeatWrapping;
  floorTexture.repeat.set(MAP_W * 2, MAP_H * 2);
  const floorMat = new THREE.MeshStandardMaterial({ map: floorTexture, roughness: 0.9, metalness: 0.1 });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.position.set(MAP_W * CELL / 2, 0, MAP_H * CELL / 2);
  floor.receiveShadow = true;
  scene.add(floor);
  levelObjects.push(floor);

  // Ceiling
  const ceilGeo = new THREE.PlaneGeometry(MAP_W * CELL, MAP_H * CELL);
  const ceilTex = generateBrickTexture(35, 35, 42);
  const ceilTexture = new THREE.CanvasTexture(ceilTex);
  ceilTexture.wrapS = THREE.RepeatWrapping;
  ceilTexture.wrapT = THREE.RepeatWrapping;
  ceilTexture.repeat.set(MAP_W, MAP_H);
  const ceilMat = new THREE.MeshStandardMaterial({ map: ceilTexture, roughness: 0.95, metalness: 0.0 });
  const ceil = new THREE.Mesh(ceilGeo, ceilMat);
  ceil.rotation.x = Math.PI / 2;
  ceil.position.set(MAP_W * CELL / 2, WALL_H, MAP_H * CELL / 2);
  scene.add(ceil);
  levelObjects.push(ceil);

  // Point lights for this level (limit count, boost range to compensate)
  const maxLights = 4;
  const lights = lvl.pointLights;
  const step = lights.length > maxLights ? Math.ceil(lights.length / maxLights) : 1;
  const intensityBoost = step > 1 ? step * 0.7 : 1;
  for (let li = 0; li < lights.length; li += step) {
    const [lx, ly, lz] = lights[li];
    const pl = new THREE.PointLight(0x4466aa, 8 * intensityBoost, 30 * Math.sqrt(intensityBoost), 1.5);
    pl.position.set(lx * CELL, ly, lz * CELL);
    scene.add(pl);
    levelObjects.push(pl);
  }

  // ========== GIANT FLOATING PRISM ==========
  const prismCX = lvl.prismPos.x * CELL, prismCZ = lvl.prismPos.z * CELL;
  const prismH = 2.5;
  const prismGeo = new THREE.ConeGeometry(0.8, prismH, 6, 1);
  const prismGeo2 = new THREE.ConeGeometry(0.8, prismH, 6, 1);
  prismGeo2.rotateX(Math.PI);

  const prismMatA = new THREE.MeshStandardMaterial({
    color: 0x4422cc,
    emissive: 0x5533ff,
    emissiveIntensity: 1.5,
    metalness: 0.9,
    roughness: 0.05,
    envMap: envMap,
    envMapIntensity: 3.0,
    flatShading: true,
    transparent: true,
    opacity: 0.85,
    side: THREE.DoubleSide,
  });

  const prismTop = new THREE.Mesh(prismGeo, prismMatA);
  const prismBot = new THREE.Mesh(prismGeo2, prismMatA.clone());
  prismBot.material.emissive = new THREE.Color(0x3322aa);

  const prismGroup = new THREE.Group();
  prismGroup.add(prismTop);
  prismGroup.add(prismBot);
  prismGroup.position.set(prismCX, WALL_H * 0.55, prismCZ);
  scene.add(prismGroup);

  // Inner glow core
  const coreGeo = new THREE.OctahedronGeometry(0.35, 0);
  const coreMat = new THREE.MeshBasicMaterial({
    color: 0xaaaaff, transparent: true, opacity: 0.6,
  });
  const core = new THREE.Mesh(coreGeo, coreMat);
  prismGroup.add(core);

  // Prism illumination light
  const prismLight = new THREE.PointLight(0x7755ff, 25, 35, 1.5);
  prismLight.position.set(prismCX, WALL_H * 0.55, prismCZ);
  scene.add(prismLight);

  // Secondary accent light below
  const prismLight2 = new THREE.PointLight(0xaa88ff, 10, 20, 2);
  prismLight2.position.set(prismCX, 0.5, prismCZ);
  scene.add(prismLight2);

  window._prism = { group: prismGroup, core, light: prismLight, light2: prismLight2 };
  levelObjects.push(prismGroup, prismLight, prismLight2);

  // Add company logo banners to inner room walls
  addLogoBanners();
}

// ============================================================
// OPTIMUS PRISME 3D MODEL (Procedural)
// ============================================================
const PRISM_PAL = [
  [20,15,105],[35,18,118],[52,16,128],[72,22,116],
  [92,28,102],[112,35,92],[128,44,84],[24,52,112],
  [18,72,118],[16,88,108],[30,30,92],[44,20,138],
  [82,14,128],[40,38,122],[58,30,110],[26,62,104]
];

function createPrismMaterial(colorIdx, opts) {
  const pal = PRISM_PAL[colorIdx % PRISM_PAL.length];
  const color = new THREE.Color().setRGB(pal[0]/255, pal[1]/255, pal[2]/255);
  return new THREE.MeshStandardMaterial({
    color: color,
    metalness: opts?.metalness ?? 0.7,
    roughness: opts?.roughness ?? 0.15,
    envMap: envMap,
    envMapIntensity: opts?.envIntensity ?? 1.5,
    flatShading: true,
    emissive: opts?.emissive ?? new THREE.Color(0x000000),
    emissiveIntensity: opts?.emissiveIntensity ?? 0,
    ...opts?.extra,
  });
}

function displaceVertices(geo, amount) {
  const pos = geo.attributes.position;
  for (let i = 0; i < pos.count; i++) {
    const seed = i * 2654435761;
    pos.setX(i, pos.getX(i) + ((seed & 0xFF) / 255 - 0.5) * amount);
    pos.setY(i, pos.getY(i) + (((seed >> 8) & 0xFF) / 255 - 0.5) * amount);
    pos.setZ(i, pos.getZ(i) + (((seed >> 16) & 0xFF) / 255 - 0.5) * amount);
  }
  geo.computeVertexNormals();
}

function createOptimusPrisme() {
  const model = new THREE.Group();
  const S = 0.85; // scale factor â€” total height ~3.2 units

  // ---- Materials ----
  const bodyMat = createPrismMaterial(0, { metalness: 0.75, roughness: 0.12 });
  const chestMat = createPrismMaterial(2, { metalness: 0.8, roughness: 0.1 });
  const shoulderMat = createPrismMaterial(3, { metalness: 0.8, roughness: 0.1, envIntensity: 2.0 });
  const armMat = createPrismMaterial(7, { metalness: 0.75, roughness: 0.12 });
  const legMat = createPrismMaterial(1, { metalness: 0.75, roughness: 0.12 });
  const bootMat = createPrismMaterial(10, { metalness: 0.7, roughness: 0.15 });
  const headMat = createPrismMaterial(11, { metalness: 0.8, roughness: 0.1 });
  const faceMat = new THREE.MeshStandardMaterial({
    color: 0x889099, metalness: 0.85, roughness: 0.15,
    envMap: envMap, envMapIntensity: 0.8, flatShading: true,
  });
  const eyeMat = new THREE.MeshStandardMaterial({
    color: 0x88ccff, emissive: 0x66bbff, emissiveIntensity: 2.5,
    metalness: 0.9, roughness: 0.05, envMap: envMap,
    envMapIntensity: 1.5, flatShading: true,
  });
  const insigniaMat = new THREE.MeshStandardMaterial({
    color: 0xff2222, emissive: 0xcc0000, emissiveIntensity: 1.2,
    metalness: 0.4, roughness: 0.3, flatShading: true,
  });
  const jointMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a2e, metalness: 0.6, roughness: 0.3,
    envMap: envMap, envMapIntensity: 0.5, flatShading: true,
  });
  const mugMat = new THREE.MeshStandardMaterial({
    color: 0xf0f0f0, roughness: 0.5, metalness: 0.05, flatShading: false,
  });
  const coffeeMat = new THREE.MeshStandardMaterial({
    color: 0x3b1f0a, roughness: 0.8, metalness: 0.0,
  });

  // Helper: make a faceted box with displaced verts
  function fBox(w,h,d,sx,sy,sz) {
    const g = new THREE.BoxGeometry(w*S,h*S,d*S, sx||2, sy||2, sz||2);
    displaceVertices(g, 0.012*S);
    return g;
  }
  function fCyl(rt,rb,h,seg) {
    const g = new THREE.CylinderGeometry(rt*S,rb*S,h*S, seg||6);
    displaceVertices(g, 0.01*S);
    return g;
  }

  // ========== TORSO (broad chest, V-taper to waist) ==========
  // Upper chest â€” wide and deep like the reference
  const torso = new THREE.Group();
  torso.name = 'torso';
  torso.position.y = 1.7 * S;
  model.add(torso);

  // Main chest block â€” wide, slightly trapezoidal
  const chestGeo = fBox(1.05, 0.55, 0.5, 4, 3, 3);
  // Taper the bottom inward for V shape
  const chestPos = chestGeo.attributes.position;
  for (let i = 0; i < chestPos.count; i++) {
    const y = chestPos.getY(i);
    if (y < -0.1 * S) {
      const taper = 1 - ((-0.1*S - y) / (0.2*S)) * 0.15;
      chestPos.setX(i, chestPos.getX(i) * taper);
    }
  }
  chestGeo.computeVertexNormals();
  const chest = new THREE.Mesh(chestGeo, chestMat);
  torso.add(chest);

  // Pectoral plates (raised panels on chest)
  for (let side = -1; side <= 1; side += 2) {
    const pecGeo = fBox(0.32, 0.22, 0.08, 3, 2, 1);
    const pec = new THREE.Mesh(pecGeo, chestMat);
    pec.position.set(side * 0.2 * S, 0.06 * S, 0.27 * S);
    torso.add(pec);
  }

  // Truck window panels (classic Optimus detail)
  for (let side = -1; side <= 1; side += 2) {
    const winGeo = fBox(0.16, 0.12, 0.03, 1, 1, 1);
    const winMat = createPrismMaterial(8, { metalness: 0.9, roughness: 0.08, envIntensity: 2.5 });
    const win = new THREE.Mesh(winGeo, winMat);
    win.position.set(side * 0.2 * S, 0.08 * S, 0.32 * S);
    torso.add(win);
  }

  // Red Autobot insignia (center chest)
  const insGeo = fBox(0.18, 0.18, 0.03, 1, 1, 1);
  const ins = new THREE.Mesh(insGeo, insigniaMat);
  ins.position.set(0, -0.08 * S, 0.28 * S);
  ins.name = 'insignia';
  torso.add(ins);

  // Collar / upper chest ridge
  const collarGeo = fBox(0.9, 0.08, 0.42, 3, 1, 2);
  const collar = new THREE.Mesh(collarGeo, bodyMat);
  collar.position.set(0, 0.3 * S, 0);
  torso.add(collar);

  // ========== HEAD (helmet with crest, faceplate, individual eyes) ==========
  const headGroup = new THREE.Group();
  headGroup.name = 'head';
  headGroup.position.y = 0.42 * S;
  torso.add(headGroup);

  // Helmet base â€” angular, wider at cheeks
  const helmetGeo = new THREE.DodecahedronGeometry(0.2 * S, 1);
  displaceVertices(helmetGeo, 0.008 * S);
  const helmet = new THREE.Mesh(helmetGeo, headMat);
  helmet.scale.set(1.15, 1.25, 1.0);
  headGroup.add(helmet);

  // Helmet brow ridge
  const browGeo = fBox(0.36, 0.04, 0.15, 2, 1, 1);
  const brow = new THREE.Mesh(browGeo, headMat);
  brow.position.set(0, 0.06 * S, 0.12 * S);
  headGroup.add(brow);

  // Central crest (tall spiky fin)
  const crestGeo = new THREE.ConeGeometry(0.03 * S, 0.28 * S, 4);
  displaceVertices(crestGeo, 0.004 * S);
  const crest = new THREE.Mesh(crestGeo, shoulderMat);
  crest.position.y = 0.38 * S;
  headGroup.add(crest);

  // Side crest fins (swept-back horns)
  for (let side = -1; side <= 1; side += 2) {
    const finGeo = new THREE.ConeGeometry(0.02 * S, 0.18 * S, 4);
    displaceVertices(finGeo, 0.003 * S);
    const fin = new THREE.Mesh(finGeo, shoulderMat);
    fin.position.set(side * 0.12 * S, 0.28 * S, -0.04 * S);
    fin.rotation.z = side * 0.25;
    fin.rotation.x = -0.2;
    headGroup.add(fin);
  }

  // Cheek guards (angular side panels)
  for (let side = -1; side <= 1; side += 2) {
    const cheekGeo = fBox(0.06, 0.16, 0.14, 2, 2, 1);
    const cheek = new THREE.Mesh(cheekGeo, headMat);
    cheek.position.set(side * 0.17 * S, -0.04 * S, 0.04 * S);
    headGroup.add(cheek);
  }

  // Faceplate (silver/metallic lower face)
  const fpGeo = fBox(0.2, 0.1, 0.08, 2, 2, 1);
  const faceplate = new THREE.Mesh(fpGeo, faceMat);
  faceplate.position.set(0, -0.1 * S, 0.15 * S);
  headGroup.add(faceplate);

  // Chin piece
  const chinGeo = fBox(0.12, 0.04, 0.06, 1, 1, 1);
  const chin = new THREE.Mesh(chinGeo, faceMat);
  chin.position.set(0, -0.16 * S, 0.14 * S);
  headGroup.add(chin);

  // Eyes (light blue glowing â€” individual eyes, not a visor)
  for (let side = -1; side <= 1; side += 2) {
    const eyeGeo = new THREE.SphereGeometry(0.028 * S, 6, 4);
    const eye = new THREE.Mesh(eyeGeo, eyeMat);
    eye.position.set(side * 0.075 * S, 0.02 * S, 0.2 * S);
    eye.scale.set(1.3, 0.7, 0.5);
    eye.name = 'eye';
    headGroup.add(eye);
  }

  // Ear receptors (glowing side discs)
  for (let side = -1; side <= 1; side += 2) {
    const earGeo = new THREE.CylinderGeometry(0.035*S, 0.035*S, 0.02*S, 6);
    const ear = new THREE.Mesh(earGeo, eyeMat);
    ear.position.set(side * 0.22 * S, 0.0 * S, 0);
    ear.rotation.z = Math.PI / 2;
    headGroup.add(ear);
  }

  // ========== SHOULDERS (massive pauldrons â€” 4 tiers, very wide) ==========
  for (let side = -1; side <= 1; side += 2) {
    const shoulderGroup = new THREE.Group();
    shoulderGroup.name = side < 0 ? 'shoulderL' : 'shoulderR';

    // Main pauldron â€” big angular block
    const padGeo = fBox(0.32, 0.18, 0.32, 3, 2, 3);
    const pad = new THREE.Mesh(padGeo, shoulderMat);
    pad.position.set(side * 0.04 * S, 0.08 * S, 0);
    shoulderGroup.add(pad);

    // Upper tier (raised ridge on top)
    const ridgeGeo = fBox(0.26, 0.06, 0.26, 2, 1, 2);
    const ridge = new THREE.Mesh(ridgeGeo, shoulderMat);
    ridge.position.set(side * 0.04 * S, 0.2 * S, 0);
    shoulderGroup.add(ridge);

    // Outer plate (extends outward)
    const outerGeo = fBox(0.14, 0.14, 0.28, 2, 2, 2);
    const outer = new THREE.Mesh(outerGeo, shoulderMat);
    outer.position.set(side * 0.18 * S, 0.06 * S, 0);
    shoulderGroup.add(outer);

    // Accent trim on pauldron edge
    const trimGeo = fBox(0.34, 0.025, 0.02, 2, 1, 1);
    const trimMat = createPrismMaterial(4, { metalness: 0.85, roughness: 0.1, envIntensity: 2.2 });
    const trim = new THREE.Mesh(trimGeo, trimMat);
    trim.position.set(side * 0.04 * S, 0.0 * S, 0.17 * S);
    shoulderGroup.add(trim);

    shoulderGroup.position.set(side * 0.56 * S, 0.2 * S, 0);
    torso.add(shoulderGroup);
  }

  // ========== ARMS (muscular upper, plated forearm, detailed hand) ==========
  const arms = { left: null, right: null };
  for (let side = -1; side <= 1; side += 2) {
    const armGroup = new THREE.Group();
    armGroup.name = side < 0 ? 'armL' : 'armR';

    // Upper arm (bicep) â€” thick, muscular shape
    const upperGeo = fCyl(0.1, 0.085, 0.38, 8);
    const upper = new THREE.Mesh(upperGeo, armMat);
    upper.position.y = -0.2 * S;
    armGroup.add(upper);

    // Bicep armor plate
    const bicepGeo = fBox(0.14, 0.18, 0.12, 2, 2, 1);
    const bicep = new THREE.Mesh(bicepGeo, armMat);
    bicep.position.set(side * 0.02 * S, -0.14 * S, 0.04 * S);
    armGroup.add(bicep);

    // Elbow joint
    const elbGeo = new THREE.SphereGeometry(0.065 * S, 8, 6);
    const elbow = new THREE.Mesh(elbGeo, jointMat);
    elbow.position.y = -0.42 * S;
    elbow.name = 'elbow';
    armGroup.add(elbow);

    // Forearm â€” bulkier, plated
    const foreGeo = fCyl(0.09, 0.075, 0.34, 8);
    const forearm = new THREE.Mesh(foreGeo, armMat);
    forearm.position.y = -0.62 * S;
    armGroup.add(forearm);

    // Forearm armor plate
    const fapGeo = fBox(0.13, 0.2, 0.1, 2, 2, 1);
    const fap = new THREE.Mesh(fapGeo, armMat);
    fap.position.set(side * 0.02 * S, -0.58 * S, 0.04 * S);
    armGroup.add(fap);

    // Wrist guard
    const wristGeo = fBox(0.12, 0.06, 0.12, 2, 1, 1);
    const wrist = new THREE.Mesh(wristGeo, bodyMat);
    wrist.position.y = -0.76 * S;
    armGroup.add(wrist);

    // Hand â€” detailed with finger segments
    const handGroup = new THREE.Group();
    handGroup.position.y = -0.84 * S;

    // Palm
    const palmGeo = fBox(0.09, 0.06, 0.08, 2, 1, 1);
    const palm = new THREE.Mesh(palmGeo, jointMat);
    handGroup.add(palm);

    // Fingers (4 blocky fingers)
    for (let f = 0; f < 4; f++) {
      const fgGeo = fBox(0.018, 0.06, 0.02, 1, 2, 1);
      const fg = new THREE.Mesh(fgGeo, jointMat);
      fg.position.set((f - 1.5) * 0.022 * S, -0.05 * S, 0.02 * S);
      handGroup.add(fg);
    }
    // Thumb
    const thumbGeo = fBox(0.02, 0.05, 0.02, 1, 1, 1);
    const thumb = new THREE.Mesh(thumbGeo, jointMat);
    thumb.position.set(side * 0.05 * S, -0.02 * S, 0.03 * S);
    thumb.rotation.z = side * 0.6;
    handGroup.add(thumb);

    armGroup.add(handGroup);

    // Coffee mug in RIGHT hand
    if (side > 0) {
      const mugGroup = new THREE.Group();
      mugGroup.position.set(0, -0.84 * S, 0.06 * S);

      // Mug body (cylinder)
      const mugBodyGeo = new THREE.CylinderGeometry(0.04*S, 0.035*S, 0.09*S, 12);
      const mugBody = new THREE.Mesh(mugBodyGeo, mugMat);
      mugGroup.add(mugBody);

      // Mug handle
      const handleGeo = new THREE.TorusGeometry(0.025*S, 0.006*S, 6, 8, Math.PI);
      const handle = new THREE.Mesh(handleGeo, mugMat);
      handle.position.set(0.045 * S, 0, 0);
      handle.rotation.y = Math.PI / 2;
      mugGroup.add(handle);

      // Coffee inside
      const coffeeGeo = new THREE.CircleGeometry(0.035*S, 10);
      const coffee = new THREE.Mesh(coffeeGeo, coffeeMat);
      coffee.position.y = 0.044 * S;
      coffee.rotation.x = -Math.PI / 2;
      mugGroup.add(coffee);

      armGroup.add(mugGroup);
    }

    armGroup.position.set(side * 0.56 * S, 0.05 * S, 0);
    torso.add(armGroup);

    if (side < 0) arms.left = armGroup;
    else arms.right = armGroup;
  }

  // ========== WAIST / HIP ARMOR ==========
  const waistGeo = fBox(0.6, 0.16, 0.35, 3, 1, 2);
  const waist = new THREE.Mesh(waistGeo, bodyMat);
  waist.position.y = 1.32 * S;
  waist.name = 'waist';
  model.add(waist);

  // Hip armor flaps
  for (let side = -1; side <= 1; side += 2) {
    const hipGeo = fBox(0.18, 0.12, 0.22, 2, 1, 2);
    const hip = new THREE.Mesh(hipGeo, bodyMat);
    hip.position.set(side * 0.22 * S, -0.06 * S, 0);
    waist.add(hip);
  }
  // Center codpiece / belt buckle
  const buckleGeo = fBox(0.12, 0.08, 0.06, 1, 1, 1);
  const buckle = new THREE.Mesh(buckleGeo, jointMat);
  buckle.position.set(0, -0.05 * S, 0.16 * S);
  waist.add(buckle);

  // ========== LEGS (muscular thighs, armored shins, heavy boots) ==========
  const legs = { left: null, right: null };
  for (let side = -1; side <= 1; side += 2) {
    const legGroup = new THREE.Group();
    legGroup.name = side < 0 ? 'legL' : 'legR';

    // Thigh â€” muscular, tapered
    const thighGeo = fCyl(0.12, 0.1, 0.42, 8);
    const thigh = new THREE.Mesh(thighGeo, legMat);
    thigh.position.y = -0.24 * S;
    legGroup.add(thigh);

    // Thigh armor plate (front)
    const thighPlateGeo = fBox(0.14, 0.22, 0.06, 2, 2, 1);
    const thighPlate = new THREE.Mesh(thighPlateGeo, legMat);
    thighPlate.position.set(0, -0.2 * S, 0.08 * S);
    legGroup.add(thighPlate);

    // Knee joint â€” armored disc
    const kneeGeo = new THREE.SphereGeometry(0.08 * S, 8, 6);
    const knee = new THREE.Mesh(kneeGeo, jointMat);
    knee.position.y = -0.48 * S;
    knee.name = 'knee';
    legGroup.add(knee);

    // Knee cap armor
    const kcGeo = fBox(0.1, 0.08, 0.06, 2, 1, 1);
    const kc = new THREE.Mesh(kcGeo, legMat);
    kc.position.set(0, -0.48 * S, 0.07 * S);
    legGroup.add(kc);

    // Shin â€” angular, with ridge
    const shinGeo = fCyl(0.1, 0.09, 0.42, 8);
    const shin = new THREE.Mesh(shinGeo, legMat);
    shin.position.y = -0.72 * S;
    legGroup.add(shin);

    // Shin armor plate (front ridge)
    const shinPlateGeo = fBox(0.08, 0.3, 0.06, 2, 3, 1);
    const shinPlate = new THREE.Mesh(shinPlateGeo, legMat);
    shinPlate.position.set(0, -0.68 * S, 0.08 * S);
    legGroup.add(shinPlate);

    // Boot â€” heavy, angular, with toe cap
    const bootGeo = fBox(0.16, 0.14, 0.24, 2, 2, 2);
    const boot = new THREE.Mesh(bootGeo, bootMat);
    boot.position.set(0, -0.98 * S, 0.02 * S);
    legGroup.add(boot);

    // Boot toe cap
    const toeGeo = fBox(0.14, 0.06, 0.06, 1, 1, 1);
    const toe = new THREE.Mesh(toeGeo, bootMat);
    toe.position.set(0, -1.0 * S, 0.14 * S);
    legGroup.add(toe);

    // Boot cuff (top rim)
    const cuffGeo = fBox(0.18, 0.04, 0.2, 2, 1, 1);
    const cuff = new THREE.Mesh(cuffGeo, bodyMat);
    cuff.position.set(0, -0.9 * S, 0.02 * S);
    legGroup.add(cuff);

    legGroup.position.set(side * 0.18 * S, 1.2 * S, 0);
    model.add(legGroup);

    if (side < 0) legs.left = legGroup;
    else legs.right = legGroup;
  }

  // Store references for animation
  model.userData = { arms, legs, headGroup, torso, waist };

  // Enemies receive shadows but don't cast (major perf win on Edge/Windows)
  model.traverse(child => {
    if (child.isMesh) {
      child.receiveShadow = true;
    }
  });

  return model;
}

// Create prototype model
const enemyPrototype = createOptimusPrisme();

// ============================================================
// WEAPON MODEL (3D Shotgun)
// ============================================================
function createWeapon() {
  const gun = new THREE.Group();
  const gunMetalMat = new THREE.MeshStandardMaterial({
    color: 0x333338, roughness: 0.3, metalness: 0.9, flatShading: true,
  });
  const woodMat = new THREE.MeshStandardMaterial({
    color: 0x5a3a1a, roughness: 0.7, metalness: 0.1, flatShading: true,
  });

  // Barrel
  const barrelGeo = new THREE.CylinderGeometry(0.015, 0.018, 0.6, 8);
  const barrel = new THREE.Mesh(barrelGeo, gunMetalMat);
  barrel.rotation.x = Math.PI / 2;
  barrel.position.set(0, 0, -0.3);
  gun.add(barrel);

  // Second barrel
  const barrel2Geo = new THREE.CylinderGeometry(0.015, 0.018, 0.6, 8);
  const barrel2 = new THREE.Mesh(barrel2Geo, gunMetalMat);
  barrel2.rotation.x = Math.PI / 2;
  barrel2.position.set(0.035, 0, -0.3);
  gun.add(barrel2);

  // Receiver
  const receiverGeo = new THREE.BoxGeometry(0.06, 0.05, 0.2);
  const receiver = new THREE.Mesh(receiverGeo, gunMetalMat);
  receiver.position.set(0.015, -0.01, -0.05);
  gun.add(receiver);

  // Stock / grip
  const stockGeo = new THREE.BoxGeometry(0.04, 0.08, 0.18);
  const stock = new THREE.Mesh(stockGeo, woodMat);
  stock.position.set(0.015, -0.02, 0.12);
  stock.rotation.x = 0.15;
  gun.add(stock);

  // Pump
  const pumpGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.12, 6);
  const pump = new THREE.Mesh(pumpGeo, woodMat);
  pump.rotation.x = Math.PI / 2;
  pump.position.set(0.015, -0.035, -0.2);
  pump.name = 'pump';
  gun.add(pump);

  // Position relative to camera
  gun.position.set(0.25, -0.2, -0.4);
  gun.rotation.y = -0.05;

  return gun;
}

const weapon = createWeapon();
camera.add(weapon);

// Muzzle flash light
const muzzleFlash = new THREE.PointLight(0xffaa44, 0, 15, 2);
muzzleFlash.position.set(0.25, -0.15, -0.9);
camera.add(muzzleFlash);

// ============================================================
// PLAYER STATE
// ============================================================
let player = {
  x: 2, y: 2, angle: 0, pitch: 0, health: 100, ammo: 50,
  kills: 0, shootCool: 0, bob: 0, hurt: 0, recoil: 0,
  jumpVel: 0, jumpY: 0,
};
const MOVE_SPEED = 3.0;
const ROT_SPEED = 0.003;

// ============================================================
// ENEMIES
// ============================================================
let enemies = [];
const ENEMY_SPEED = 1.2;
const ENEMY_ATTACK_RANGE = 0.8;
const ENEMY_ATTACK_COOL = 60;
const ENEMY_HP = 3;

// Health kits
let healthKits = [];
const HEALTH_KIT_HEAL = 15;
const HEALTH_KIT_RANGE = 0.8;

function createHealthKitModel() {
  const group = new THREE.Group();
  // White box
  const boxGeo = new THREE.BoxGeometry(0.4, 0.25, 0.4);
  const boxMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.4, metalness: 0.1 });
  const box = new THREE.Mesh(boxGeo, boxMat);
  group.add(box);
  // Red cross (horizontal bar)
  const barH = new THREE.Mesh(
    new THREE.BoxGeometry(0.25, 0.02, 0.08),
    new THREE.MeshStandardMaterial({ color: 0xff2222, emissive: 0xaa0000, emissiveIntensity: 0.5, roughness: 0.3 })
  );
  barH.position.set(0, 0.13, 0);
  group.add(barH);
  // Red cross (vertical bar)
  const barV = new THREE.Mesh(
    new THREE.BoxGeometry(0.08, 0.02, 0.25),
    new THREE.MeshStandardMaterial({ color: 0xff2222, emissive: 0xaa0000, emissiveIntensity: 0.5, roughness: 0.3 })
  );
  barV.position.set(0, 0.13, 0);
  group.add(barV);
  return group;
}

function spawnHealthKits() {
  for (const kit of healthKits) {
    if (kit.model) scene.remove(kit.model);
  }
  healthKits = [];
  const spots = LEVELS[currentLevel].healthKits || [];
  for (const [x, y] of spots) {
    if (MAP[y][x] === 0) {
      const model = createHealthKitModel();
      const wx = (x + 0.5) * CELL;
      const wz = (y + 0.5) * CELL;
      model.position.set(wx, 0.15, wz);
      scene.add(model);
      healthKits.push({ x: x + 0.5, y: y + 0.5, model, picked: false });
    }
  }
}

// Crystal shard pool for death effects
const shardPool = [];
const SHARD_GEO = new THREE.TetrahedronGeometry(0.08, 0);
const shardMats = PRISM_PAL.map((pal, i) => createPrismMaterial(i, { envIntensity: 2.0 }));

function setupModelUserData(model) {
  // After cloning, re-establish references by name
  const ud = { arms: {}, legs: {} };
  model.traverse(child => {
    if (child.name === 'armL') ud.arms.left = child;
    if (child.name === 'armR') ud.arms.right = child;
    if (child.name === 'legL') ud.legs.left = child;
    if (child.name === 'legR') ud.legs.right = child;
    if (child.name === 'head') ud.headGroup = child;
    if (child.name === 'torso') ud.torso = child;
    if (child.name === 'waist') ud.waist = child;
  });
  model.userData = ud;
}

function spawnEnemies() {
  // Remove old models
  for (const e of enemies) {
    if (e.model) scene.remove(e.model);
  }
  // Remove old shards
  for (const s of shardPool) scene.remove(s);
  shardPool.length = 0;

  enemies = [];
  const spots = LEVELS[currentLevel].enemySpots;
  for (const [x, y] of spots) {
    if (MAP[y][x] === 0) {
      const model = enemyPrototype.clone();
      // Deep clone materials so pain flash works per-enemy, cache mesh list
      const meshes = [];
      model.traverse(child => {
        if (child.isMesh) {
          child.material = child.material.clone();
          meshes.push(child);
        }
      });
      setupModelUserData(model);
      const wx = (x + 0.5) * CELL;
      const wz = (y + 0.5) * CELL;
      model.position.set(wx, 0, wz);
      scene.add(model);

      enemies.push({
        x: x + 0.5, y: y + 0.5, hp: ENEMY_HP, cooldown: 0,
        state: 'idle', pain: 0, dead: false, deathTimer: 0,
        model, meshes, walkPhase: Math.random() * Math.PI * 2,
        origMaterials: null, losFrame: 0,
      });
    }
  }
}

// ============================================================
// INPUT
// ============================================================
const keys = {};
let shooting = false;
let locked = false;

function clearKeys() { for (const k in keys) keys[k] = false; shooting = false; }
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
window.addEventListener('blur', clearKeys);
document.addEventListener('mousemove', e => {
  if (locked) {
    player.angle += e.movementX * ROT_SPEED;
    player.pitch -= e.movementY * ROT_SPEED * 0.8;
    player.pitch = Math.max(-1.2, Math.min(1.2, player.pitch));
  }
});
document.addEventListener('mousedown', () => { if (locked) shooting = true; });
document.addEventListener('mouseup', () => shooting = false);
document.addEventListener('pointerlockchange', () => {
  locked = !!document.pointerLockElement;
  if (!locked) clearKeys();
});

// ============================================================
// COLLISION (same as original)
// ============================================================
function canSee(x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const step = 0.1;
  for (let t = 0; t < dist; t += step) {
    const cx = x1 + (dx / dist) * t;
    const cy = y1 + (dy / dist) * t;
    if (MAP[Math.floor(cy)][Math.floor(cx)] !== 0) return false;
  }
  return true;
}

// ============================================================
// GAME STATE
// ============================================================
let gameState = 'menu';
let deadCount = 0;
const msgEl = document.getElementById('msg');
const startEl = document.getElementById('start');
const damageFlash = document.getElementById('damageFlash');
const hpEl = document.getElementById('hp');
const ammoEl = document.getElementById('ammo');
const killsEl = document.getElementById('kills');

function showMessage(lines) {
  while (msgEl.firstChild) msgEl.removeChild(msgEl.firstChild);
  lines.forEach((line, i) => {
    if (i > 0) msgEl.appendChild(document.createElement('br'));
    const span = document.createElement('span');
    if (line.style) Object.assign(span.style, line.style);
    span.textContent = line.text;
    msgEl.appendChild(span);
  });
  msgEl.style.display = 'block';
  document.getElementById('version').style.display = '';
}

function startGame(levelIndex) {
  if (levelIndex !== undefined) currentLevel = levelIndex;
  const lvl = LEVELS[currentLevel];
  clearLevel();
  loadLevelData(currentLevel);
  player = {
    x: lvl.playerStart.x, y: lvl.playerStart.y, angle: 0, pitch: 0,
    health: 100, ammo: lvl.playerAmmo,
    kills: 0, shootCool: 0, bob: 0, hurt: 0, recoil: 0,
    jumpVel: 0, jumpY: 0,
  };
  buildLevel();
  spawnEnemies();
  spawnHealthKits();
  deadCount = 0;
  gameState = 'playing';
  // Resize minimap canvas once per level
  const MINI_CELL = getMiniCell();
  miniCanvas.width = MAP_W * MINI_CELL;
  miniCanvas.height = MAP_H * MINI_CELL;
  // Render static wall layer to offscreen canvas
  miniWallCanvas = document.createElement('canvas');
  miniWallCanvas.width = miniCanvas.width;
  miniWallCanvas.height = miniCanvas.height;
  const mwCtx = miniWallCanvas.getContext('2d');
  mwCtx.fillStyle = '#000';
  mwCtx.fillRect(0, 0, miniWallCanvas.width, miniWallCanvas.height);
  for (let r = 0; r < MAP_H; r++) {
    for (let c = 0; c < MAP_W; c++) {
      if (MAP[r][c] !== 0) {
        mwCtx.fillStyle = '#555';
        mwCtx.fillRect(c * MINI_CELL, r * MINI_CELL, MINI_CELL, MINI_CELL);
      }
    }
  }
  startEl.style.display = 'none';
  msgEl.style.display = 'none';
  document.getElementById('version').style.display = 'none';
  renderer.domElement.requestPointerLock();
}

document.addEventListener('click', () => {
  if (gameState === 'menu') startGame(0);
});
renderer.domElement.addEventListener('click', () => {
  if (!locked && gameState !== 'menu') renderer.domElement.requestPointerLock();
});

// ============================================================
// DEATH SHATTER EFFECT
// ============================================================
function spawnShards(wx, wz) {
  for (let i = 0; i < 25; i++) {
    const mat = shardMats[Math.floor(Math.random() * shardMats.length)].clone();
    const shard = new THREE.Mesh(SHARD_GEO, mat);
    shard.position.set(
      wx + (Math.random() - 0.5) * 0.8,
      0.5 + Math.random() * 2,
      wz + (Math.random() - 0.5) * 0.8
    );
    shard.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
    shard.userData.vel = new THREE.Vector3(
      (Math.random() - 0.5) * 6,
      3 + Math.random() * 5,
      (Math.random() - 0.5) * 6
    );
    shard.userData.life = 2.0;
    shard.scale.setScalar(0.5 + Math.random() * 1.0);
    scene.add(shard);
    shardPool.push(shard);
  }
}

// ============================================================
// UPDATE
// ============================================================
let muzzleTimer = 0;

function update(dt) {
  if (gameState !== 'playing') return;

  // --- Player movement ---
  let mx = 0, my = 0;
  const cos = Math.cos(player.angle), sin = Math.sin(player.angle);
  if (keys['w'] || keys['arrowup']) { mx += cos; my += sin; }
  if (keys['s'] || keys['arrowdown']) { mx -= cos; my -= sin; }
  if (keys['a'] || keys['arrowleft']) { mx += sin; my -= cos; }
  if (keys['d'] || keys['arrowright']) { mx -= sin; my += cos; }
  const len = Math.sqrt(mx * mx + my * my);
  if (len > 0) {
    mx = (mx / len) * MOVE_SPEED * dt;
    my = (my / len) * MOVE_SPEED * dt;
    player.bob += dt * 10;
    const nx = player.x + mx;
    const ny = player.y + my;
    if (MAP[Math.floor(player.y)][Math.floor(nx)] === 0) player.x = nx;
    if (MAP[Math.floor(ny)][Math.floor(player.x)] === 0) player.y = ny;
  }

  // --- Health kit pickup & animation ---
  for (const kit of healthKits) {
    if (kit.picked) continue;
    // Bobbing
    kit.model.position.y = 0.15 + Math.sin(Date.now() * 0.003) * 0.08;
    kit.model.rotation.y += dt * 1.5;
    // Pickup check
    const kdx = player.x - kit.x, kdy = player.y - kit.y;
    if (kdx * kdx + kdy * kdy < HEALTH_KIT_RANGE * HEALTH_KIT_RANGE && player.health < 100) {
      kit.picked = true;
      scene.remove(kit.model);
      player.health = Math.min(100, player.health + HEALTH_KIT_HEAL);
    }
  }

  // --- Camera ---
  // Jump
  if (keys[' '] && player.jumpY === 0) player.jumpVel = 6;
  if (player.jumpY > 0 || player.jumpVel > 0) {
    player.jumpVel -= 20 * dt; // gravity
    player.jumpY += player.jumpVel * dt;
    if (player.jumpY <= 0) { player.jumpY = 0; player.jumpVel = 0; }
    if (player.jumpY > WALL_H * 0.4) { player.jumpY = WALL_H * 0.4; player.jumpVel = 0; }
  }

  const bobOffset = len > 0 ? Math.sin(player.bob) * 0.06 : 0;
  const eyeHeight = WALL_H * 0.45 + bobOffset + player.jumpY;
  camera.position.set(player.x * CELL, eyeHeight, player.y * CELL);
  camera.rotation.y = -player.angle - Math.PI / 2;
  camera.rotation.x = player.pitch;

  // --- Weapon bob & recoil ---
  if (player.recoil > 0) player.recoil *= 0.85;
  if (player.recoil < 0.01) player.recoil = 0;
  const weaponBob = len > 0 ? Math.sin(player.bob * 1.5) * 0.008 : 0;
  weapon.position.set(0.25, -0.2 + weaponBob, -0.4 + player.recoil * 0.003);
  weapon.rotation.x = -player.recoil * 0.003;

  // --- Muzzle flash ---
  if (muzzleTimer > 0) {
    muzzleTimer -= dt;
    muzzleFlash.intensity = muzzleTimer > 0 ? 30 : 0;
  } else {
    muzzleFlash.intensity = 0;
  }

  // --- Shooting ---
  if (player.shootCool > 0) player.shootCool -= dt;
  if (shooting && player.ammo > 0 && player.shootCool <= 0) {
    player.ammo--;
    player.shootCool = 0.3;
    player.hurt = 3;
    player.recoil = 0.5;
    muzzleTimer = 0.05;

    // Hit detection (angle-based, same as original)
    let closestEnemy = null, closestDist = Infinity;
    for (const e of enemies) {
      if (e.dead) continue;
      const dx = e.x - player.x, dy = e.y - player.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      let eAngle = Math.atan2(dy, dx) - player.angle;
      while (eAngle < -Math.PI) eAngle += Math.PI * 2;
      while (eAngle > Math.PI) eAngle -= Math.PI * 2;
      const halfWidth = 0.4 / dist;
      if (Math.abs(eAngle) < halfWidth && dist < closestDist) {
        if (canSee(player.x, player.y, e.x, e.y)) {
          closestDist = dist;
          closestEnemy = e;
        }
      }
    }
    if (closestEnemy) {
      closestEnemy.hp--;
      closestEnemy.pain = 0.3; // seconds
      closestEnemy.state = 'chase';
      if (closestEnemy.hp <= 0) {
        closestEnemy.dead = true;
        closestEnemy.deathTimer = 3;
        player.kills++;
        deadCount++;
        // Shatter effect
        closestEnemy.model.visible = false;
        spawnShards(
          closestEnemy.model.position.x,
          closestEnemy.model.position.z
        );
      }
    }
  }

  // --- Enemy AI ---
  for (const e of enemies) {
    if (e.dead) {
      if (e.deathTimer > 0) e.deathTimer -= dt;
      continue;
    }

    // Pain flash (uses cached meshes array)
    if (e.pain > 0) {
      e.pain -= dt;
      for (const child of e.meshes) {
        child.material.emissive = child.material.emissive || new THREE.Color();
        if (e.pain > 0) {
          child.material.emissive.setHex(0xff0000);
          child.material.emissiveIntensity = 2.0;
        } else {
          if (child.name === 'eye') {
            child.material.emissive.setHex(0x66bbff);
            child.material.emissiveIntensity = 2.5;
          } else if (child.name === 'insignia') {
            child.material.emissive.setHex(0xff0000);
            child.material.emissiveIntensity = 0.8;
          } else if (child.name === 'elbow' || child.name === 'knee') {
            child.material.emissive.setHex(0x006666);
            child.material.emissiveIntensity = 0.6;
          } else {
            child.material.emissive.setHex(0x000000);
            child.material.emissiveIntensity = 0;
          }
        }
      }
    }

    if (e.cooldown > 0) e.cooldown -= dt * 60;

    const dx = player.x - e.x, dy = player.y - e.y;
    const distSq = dx * dx + dy * dy;
    const dist = Math.sqrt(distSq);

    // Throttle LoS checks for idle enemies (every ~6 frames via staggered timer)
    if (e.state === 'idle') {
      e.losFrame = (e.losFrame + 1) % 6;
      if (e.losFrame === 0 && distSq < 100 && canSee(e.x, e.y, player.x, player.y)) {
        e.state = 'chase';
      }
    } else if (distSq < 100 && canSee(e.x, e.y, player.x, player.y)) {
      e.state = 'chase';
    }

    if (e.state === 'chase') {
      if (dist > ENEMY_ATTACK_RANGE) {
        const ndx = (dx / dist) * ENEMY_SPEED * dt;
        const ndy = (dy / dist) * ENEMY_SPEED * dt;
        const nx = e.x + ndx, ny = e.y + ndy;
        if (MAP[Math.floor(e.y)][Math.floor(nx)] === 0) e.x = nx;
        if (MAP[Math.floor(ny)][Math.floor(e.x)] === 0) e.y = ny;
      } else if (e.cooldown <= 0) {
        player.health -= 8 + Math.floor(Math.random() * 5);
        player.hurt = 10;
        e.cooldown = ENEMY_ATTACK_COOL;
        if (player.health <= 0) {
          player.health = 0;
          gameState = 'dead';
          showMessage([
            { text: 'YOU DIED' },
            { text: 'Click to restart', style: { fontSize: '24px', color: '#aaa' } }
          ]);
          document.exitPointerLock();
          setTimeout(() => {
            document.addEventListener('click', function restart() {
              document.removeEventListener('click', restart);
              startGame(currentLevel);
            }, { once: false });
          }, 500);
        }
      }
    }

    // Update model position and rotation
    const wx = e.x * CELL;
    const wz = e.y * CELL;
    e.model.position.set(wx, 0, wz);

    // Face player
    const faceAngle = Math.atan2(
      player.x * CELL - wx,
      player.y * CELL - wz
    );
    e.model.rotation.y = faceAngle;

    // Walk animation
    if (e.state === 'chase' && dist > ENEMY_ATTACK_RANGE) {
      e.walkPhase += dt * 6;
      const swing = Math.sin(e.walkPhase) * 0.4;
      const ud = e.model.userData;
      if (ud.legs) {
        if (ud.legs.left) ud.legs.left.rotation.x = swing;
        if (ud.legs.right) ud.legs.right.rotation.x = -swing;
      }
      if (ud.arms) {
        if (ud.arms.left) ud.arms.left.rotation.x = -swing * 0.6;
        if (ud.arms.right) ud.arms.right.rotation.x = swing * 0.6;
      }
    } else {
      // Idle pose - slight idle animation
      const ud = e.model.userData;
      if (ud.legs) {
        if (ud.legs.left) ud.legs.left.rotation.x = 0;
        if (ud.legs.right) ud.legs.right.rotation.x = 0;
      }
      if (ud.arms) {
        if (ud.arms.left) ud.arms.left.rotation.x = 0;
        if (ud.arms.right) ud.arms.right.rotation.x = 0;
      }
    }
  }

  // --- Win condition ---
  if (enemies.length > 0 && deadCount >= enemies.length) {
    if (currentLevel < LEVELS.length - 1) {
      gameState = 'win';
      showMessage([
        { text: 'LEVEL ' + (currentLevel + 1) + ' COMPLETE!' },
        { text: 'Click to continue to ' + LEVELS[currentLevel + 1].name, style: { fontSize: '24px', color: '#aaa' } }
      ]);
      document.exitPointerLock();
      setTimeout(() => {
        document.addEventListener('click', function nextLevel() {
          document.removeEventListener('click', nextLevel);
          startGame(currentLevel + 1);
        }, { once: false });
      }, 500);
    } else {
      gameState = 'win';
      showMessage([
        { text: 'YOU WIN!', style: { color: '#0f0', textShadow: '0 0 20px #0f0' } },
        { text: 'All levels complete!', style: { fontSize: '24px', color: '#aaa' } },
        { text: 'Click to play again', style: { fontSize: '20px', color: '#888' } }
      ]);
      document.exitPointerLock();
      setTimeout(() => {
        document.addEventListener('click', function restart() {
          document.removeEventListener('click', restart);
          startGame(0);
        }, { once: false });
      }, 500);
    }
  }

  // --- Update shards ---
  for (let i = shardPool.length - 1; i >= 0; i--) {
    const s = shardPool[i];
    s.userData.life -= dt;
    if (s.userData.life <= 0) {
      s.material.dispose();
      scene.remove(s);
      shardPool.splice(i, 1);
      continue;
    }
    s.userData.vel.y -= 12 * dt; // gravity
    s.position.addScaledVector(s.userData.vel, dt);
    s.rotation.x += dt * 5;
    s.rotation.z += dt * 3;
    if (s.position.y < 0) {
      s.position.y = 0;
      s.userData.vel.y *= -0.3;
      s.userData.vel.x *= 0.7;
      s.userData.vel.z *= 0.7;
    }
    // Fade out
    if (s.userData.life < 0.5) {
      s.material.opacity = s.userData.life / 0.5;
      s.material.transparent = true;
    }
  }

  // --- HUD ---
  hpEl.textContent = Math.max(0, player.health);
  ammoEl.textContent = player.ammo;
  killsEl.textContent = player.kills + '/' + enemies.length;

  // Damage flash
  if (player.hurt > 0) {
    player.hurt -= dt * 15;
    damageFlash.style.background = `rgba(255,0,0,${Math.min(0.4, player.hurt * 0.04)})`;
  } else {
    damageFlash.style.background = 'rgba(255,0,0,0)';
  }
}

// ============================================================
// MINIMAP
// ============================================================
const miniCanvas = document.getElementById('minimap');
const miniCtx = miniCanvas.getContext('2d');
let miniWallCanvas = null;

function getMiniCell() {
  return Math.floor(160 / Math.max(MAP_W, MAP_H));
}

function drawMinimap() {
  const MINI_CELL = getMiniCell();
  const mw = miniCanvas.width;
  const mh = miniCanvas.height;
  // Draw cached static wall layer (or fallback for menu)
  if (miniWallCanvas) {
    miniCtx.drawImage(miniWallCanvas, 0, 0);
  } else {
    miniCtx.fillStyle = '#000';
    miniCtx.fillRect(0, 0, mw, mh);
    for (let r = 0; r < MAP_H; r++) {
      for (let c = 0; c < MAP_W; c++) {
        if (MAP[r][c] !== 0) {
          miniCtx.fillStyle = '#555';
          miniCtx.fillRect(c * MINI_CELL, r * MINI_CELL, MINI_CELL, MINI_CELL);
        }
      }
    }
  }
  // Player
  miniCtx.fillStyle = '#0f0';
  miniCtx.beginPath();
  miniCtx.arc(player.x * MINI_CELL, player.y * MINI_CELL, 3, 0, Math.PI * 2);
  miniCtx.fill();
  // Player direction
  miniCtx.strokeStyle = '#0f0';
  miniCtx.beginPath();
  miniCtx.moveTo(player.x * MINI_CELL, player.y * MINI_CELL);
  miniCtx.lineTo(
    player.x * MINI_CELL + Math.cos(player.angle) * 8,
    player.y * MINI_CELL + Math.sin(player.angle) * 8
  );
  miniCtx.stroke();
  // Health kits
  for (const kit of healthKits) {
    if (kit.picked) continue;
    miniCtx.fillStyle = '#fff';
    miniCtx.fillRect(kit.x * MINI_CELL - 2, kit.y * MINI_CELL - 1, 4, 2);
    miniCtx.fillRect(kit.x * MINI_CELL - 1, kit.y * MINI_CELL - 2, 2, 4);
  }
  // Enemies
  for (const e of enemies) {
    if (e.dead) continue;
    miniCtx.fillStyle = '#f00';
    miniCtx.beginPath();
    miniCtx.arc(e.x * MINI_CELL, e.y * MINI_CELL, 2, 0, Math.PI * 2);
    miniCtx.fill();
  }
}

// ============================================================
// RESIZE
// ============================================================
function onResize() {
  const w = window.innerWidth;
  const h = window.innerHeight - 63;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
}
window.addEventListener('resize', onResize);

// ============================================================
// GAME LOOP
// ============================================================
buildLevel();

// Set initial camera position so the menu screen isn't grey
camera.position.set(player.x * CELL, WALL_H * 0.45, player.y * CELL);
camera.rotation.order = 'YXZ';
camera.rotation.y = -player.angle - Math.PI / 2;

let lastTime = 0;
function gameLoop(time) {
  requestAnimationFrame(gameLoop);
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;

  update(dt);
  // Animate floating prism
  if (window._prism) {
    const p = window._prism;
    const t = time * 0.001;
    p.group.rotation.y = t * 0.4;
    p.group.position.y = WALL_H * 0.55 + Math.sin(t * 0.8) * 0.3;
    p.core.rotation.y = -t * 1.2;
    p.core.rotation.x = t * 0.7;
    const pulse = 0.85 + Math.sin(t * 1.5) * 0.15;
    p.light.intensity = 25 * pulse;
    p.light.position.y = p.group.position.y;
    p.light2.intensity = 10 * pulse;
  }

  renderer.render(scene, camera);
  drawMinimap();
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
